/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/fa5194b7-e72f-4137-a76a-a7547f31617d

  Project available here: https://create.arduino.cc/projecthub/cdtoews/kombucha-heater-61dacc
  Code available here: https://github.com/cdtoews/kombucha


*/

//for local running
#include <arduino_secrets.h>
#include<BlynkSimpleWiFiNINA.h>
#include "Adafruit_MQTT.h"
#include "Adafruit_MQTT_Client.h"

#define DEBUG 1

#if DEBUG == 1
#define debugSerial(x) Serial.print(x)
#define debugSerialln(x) Serial.println(x)
#else
#define debugSerial(x)
#define debugSerialln(x)
#endif


#include <Arduino_MKRIoTCarrier.h>
MKRIoTCarrier carrier;


float humidity;
bool doorOpen;
float currentTempF;
int currentStatus;
int highTemp;
int intensityIncrementAmount;
int lowTemp;
int lowTempIntensity;
int relayState;

//for AHT20 temp sensor
#include <Wire.h>
#include <SparkFun_Qwiic_Humidity_AHT20.h>
AHT20 humiditySensor;

//timer stuff
#include <arduino-timer.h>
auto timer = timer_create_default(); // create a timer with default settings

//Door sensor / LEDs
#define DOORPIN  A5
int doorState = 0;
long checkDoorInterval = 1000; // every 1 seconds check the door
long AdafruitTimerRepeat = 60000; //every minute
long AdafruitPullTimerRepeat = 60000; //every minute
long AdafruitTriggerPullTimerRepeat = 3600000;// every hour

uint32_t ledOn = carrier.leds.Color( 255, 255, 255);
uint32_t ledOff = carrier.leds.Color( 0, 0, 0);

#define RELAYPIN A6

#define BACKGROUND_COLOR ST77XX_BLACK
#define TEXT_COLOR ST77XX_WHITE
#define HIGH_TEXT_COLOR ST77XX_RED
#define OFF_TEXT_COLOR ST77XX_BLUE
#define LOW_TEXT_COLOR ST77XX_MAGENTA
static int TEXT_SIZE = 3;
static int smaller_TEXT_SIZE = 2;

// You should get Auth Token in the Blynk App.
char auth[] = BLYNK_AUTH_TOKEN;

// Your WiFi credentials.
char ssid[] = WIFI_SSID;
char pass[] = WIFI_PASS;

/************************* Adafruit.io Setup *********************************/
#define AIO_SERVER      "io.adafruit.com"
#define AIO_SERVERPORT  1883                   // use 8883 for SSL
#define AIO_USERNAME    IO_USERNAME
#define AIO_KEY         IO_KEY

WiFiClient client;

// Setup the MQTT client class by passing in the WiFi client and MQTT server and login details.
Adafruit_MQTT_Client mqtt(&client, AIO_SERVER, AIO_SERVERPORT, AIO_USERNAME, AIO_KEY);

/****************************** Feeds ***************************************/

// Notice MQTT paths for AIO follow the form: <username>/feeds/<feedname>
Adafruit_MQTT_Publish tempPub = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/temperature");
Adafruit_MQTT_Publish humidityPub = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/humiditiy");
Adafruit_MQTT_Publish lightPub = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/light");
Adafruit_MQTT_Publish thermostatStatusPub = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/kombuha.thermostatstatus");
Adafruit_MQTT_Publish lowTempPercentagePub = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/kombuha.lowtemppercentage");

//publishes for getting latest
Adafruit_MQTT_Publish sethightempGet = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/kombuha.hightemp/get");
Adafruit_MQTT_Publish setlowtempGet = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/kombuha.lowtemp/get");
Adafruit_MQTT_Publish lowTempPercentageGet = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/kombuha.lowtemppercentage/get");

//subscriptions
Adafruit_MQTT_Subscribe sethightemp = Adafruit_MQTT_Subscribe(&mqtt, AIO_USERNAME "/feeds/kombuha.hightemp");
Adafruit_MQTT_Subscribe setlowtemp = Adafruit_MQTT_Subscribe(&mqtt, AIO_USERNAME "/feeds/kombuha.lowtemp");
Adafruit_MQTT_Subscribe lowTempPercentageSub = Adafruit_MQTT_Subscribe(&mqtt, AIO_USERNAME "/feeds/kombuha.lowtemppercentage");


long readTempRepeat = 15000;
bool updateToBlynk = false;
bool updateToAdafruit = true;
bool updateFromAdafruit = true;

float tempF = -1.0;
const int tempsToRound = 4; //We take this many temp/humidity readings and average them
float temps[tempsToRound]; //hold temp readings to average
float humidities[tempsToRound]; //hold humidity readings to average
int tempsArrayIndicator = 0; //keep track of which element in array we are updating, this will be for rounding temps
//these are initial and default settings and will be overwritten from arduino
int highSetTemp = 79; //default setting, in case we can't get out over the intertubes
int lowSetTemp = 77; //default setting, in case we can't get out over the intertubes

// low heat setting (cycling heat on and off)
long lowTempCycleDuration = 1800000; //amount of time to cyle on&off when on Low temp setting //600000 10 minutes, 3600000 1 hour //
int lowTempCyclePercentUp = 50; //good starting point.
long cycleUpTime; //this will be calculated
long cycleDownTime;//this will be calculated
long cycleLastChange = millis();
long startMillis = millis();
long lastChangeMillis = millis();

//statuses
const int statusInitializing = -1;
const int statusOff = 0;
const int statusLow = 1;
const int statusHigh = 2;

char statusInitializingText[] = "init";
char statusOffText[] = "Off";
char statusLowText[] = "low";
char statusHighText[] = "High";
char statusUnknownText[] = "????";

void MQTT_connect();
//###########################################
//################ SETUP  ###################
//###########################################
void setup() {
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);
  Blynk.begin(auth, ssid, pass);


  //subscribe to settings
  mqtt.subscribe(&sethightemp);
  mqtt.subscribe(&setlowtemp);
  mqtt.subscribe(&lowTempPercentageSub);

  //calculate how long heat stays on for low heat setting. hopefully re-done if connected to IOT
  cycleUpTime = (lowTempCycleDuration * lowTempIntensity) / 100;
  cycleDownTime = lowTempCycleDuration - cycleUpTime;
  currentStatus = statusInitializing; //what the status is

  //Check if the AHT20 will acknowledge
  Wire.begin(); //Join I2C bus
  if (humiditySensor.begin() == false) {
    debugSerialln("AHT20 not detected. Please check wiring. Freezing.");
    while (1);
  }
  debugSerialln("AHT20 acknowledged.");

  pinMode(RELAYPIN, OUTPUT);     //Set relay pin as output
  pinMode(DOORPIN, INPUT_PULLUP); //set input for door

  //let's take a quick temp, so arduino doesn't think the temp is zero
  float tempC = humiditySensor.getTemperature();
  currentTempF = roundFloat(float((tempC * 1.8) + 32));
  humidity = humiditySensor.getHumidity();

  delay(500);
  CARRIER_CASE = true;
  carrier.begin();
  carrier.display.setRotation(0);

  //set timers
  timer.every(readTempRepeat, readTemp);
  timer.every(checkDoorInterval, checkDoor);

  if (updateToAdafruit) {
    delay(5000);
    timer.every(AdafruitTimerRepeat, updateAdafruit);
  }
  if (updateFromAdafruit) {
    delay(2000);
    //timer.in(2000, triggerGetFromAdafruit); //trigger a pull in 2 secs
    timer.every(AdafruitTriggerPullTimerRepeat, triggerGetFromAdafruit);
    delay(2000);
    timer.every(AdafruitPullTimerRepeat , pullFromAdafruit);
  }

  updateScreen();
  printRow(F( "Finished Setup"));
  Serial.println(F("Finished Setup"));
}


//############ LOOP  ##############
void loop() {

  timer.tick();
}



//############ Trigger Get from Adafruit  ##############
bool triggerGetFromAdafruit(void *) {
  debugSerialln("triggering a get to adafruit hightemp and lowtemp");
  MQTT_connect();


  //let's do low temp first
  //first we need to publish to the /get feed
  debugSerial("Sending to low temp get ... ");
  if (! setlowtempGet.publish(0.0)) {
    debugSerialln(F("Failed"));
  } else {
    debugSerialln(F("OK!"));
  }

  //now let's do the high temp
  debugSerial("Sending to high temp get ... ");
  if (! sethightempGet.publish(0.0)) {
    debugSerialln(F("Failed"));
  } else {
    debugSerialln(F("OK!"));
  }

  debugSerial("Sending to low percentage get ... ");
  if (! lowTempPercentageGet.publish(0.0)) {
    debugSerialln(F("Failed"));
  } else {
    debugSerialln(F("OK!"));
  }

}

//############ Pull from Adafruit  ##############
bool pullFromAdafruit(void *) {
  debugSerialln("going to update FROM adafruit");
  MQTT_connect();
  // this is our 'wait for incoming subscription packets' busy subloop
  Adafruit_MQTT_Subscribe *subscription;
  while ((subscription = mqtt.readSubscription(5000))) {

    if (subscription == &lowTempPercentageSub) {
      lowTempCyclePercentUp =  atoi((char *)lowTempPercentageSub.lastread);
      cycleUpTime = (lowTempCycleDuration * lowTempCyclePercentUp) / 100;
      cycleDownTime = lowTempCycleDuration - cycleUpTime;
      debugSerial(F("New low temp cycle, cycle up Percent:"));
      debugSerialln(lowTempCyclePercentUp);
      delay(1000);
    } else {
      debugSerial(F("---no low temp percentage update---"));
    }

    // Check high temp first
    if (subscription == &sethightemp) {
      debugSerial("high temp pulled from subscription : ");
      debugSerial((char *)sethightemp.lastread);
      debugSerial("   SET high temp ");
      highSetTemp =  atoi((char *)sethightemp.lastread);
      debugSerialln(highSetTemp);
      printRowInt( "hi temp: ", highSetTemp);
      delay(1000);
    } else {
      debugSerial(F("---no high temp update---"));
    }

    // check low temp now
    if (subscription == &setlowtemp) {
      debugSerial("got LOW temp pulled from subscription: ");
      debugSerial((char *)setlowtemp.lastread);
      debugSerial("   SET low temp ");
      lowSetTemp = atoi((char *)setlowtemp.lastread);
      debugSerialln(lowSetTemp);
      printRowInt( "lo temp: ",  lowSetTemp);
      delay(1000);
    } else {
      debugSerial(F("---no low temp update---"));
    }


  }
  return true;
}


//############ Update TO Adafruit ##############
bool updateAdafruit(void *) {
  debugSerialln("updating Adafruit");

  printRow( "Updating Adafruit");
  MQTT_connect();

  debugSerialln("going to update TO adafruit");
  uint32_t unsignedRelayState = digitalRead(RELAYPIN);

  printRow( "tempPub Adafruit");
  // Now we can publish stuff!
  debugSerial("Sending temp to adafruit val ");
  debugSerial(tempF);
  ("...");
  if (! tempPub.publish(tempF)) {
    debugSerialln(F("Failed"));
  } else {
    debugSerialln(F("OK!"));
  }

  printRow( "RHPub Adafruit");
  // Now we can publish stuff!
  debugSerial("Sending humidity val ");
  debugSerial(humidity);
  debugSerial("...");
  if (! humidityPub.publish(humidity)) {
    debugSerialln(F("Failed"));
  } else {
    debugSerialln(F("OK!"));
  }

  printRow("relayPub Adafruit");
  // Now we can publish stuff!
  debugSerial("Sending relay state val ... ");
  if (! lightPub.publish(unsignedRelayState)) {
    debugSerialln(F("Failed"));
  } else {
    debugSerialln(F("OK!"));
  }

  printRow( "thstatPub Adafruit");
  //thermostatStatusPub
  // Now we can publish stuff!
  debugSerial("Sending current thermostat status val ... ");
  uint32_t unsignedStatus = currentStatus;
  if (! thermostatStatusPub.publish(unsignedStatus)) {
    debugSerialln(F("Failed"));
  } else {
    debugSerialln(F("OK!"));
  }
  printRow( "Updated Adafruit");
}


//############ check sensor at door  ##############
bool checkDoor(void *) {
  doorState = digitalRead(DOORPIN);
  if (doorState == HIGH) {
    if (!doorOpen) {
      //door just opened
      debugSerial("door opened, ");
      debugSerialln(millis());
      doorOpen = true;
      carrier.leds.fill(ledOn, 0, 5);
      carrier.leds.show();
      printRow(F("Door Opened"));
      delay(2000);
    }
  } else {
    if (doorOpen) {
      //door just closed
      debugSerial("door closed, ");
      debugSerialln(millis());
      doorOpen = false;
      carrier.leds.fill(ledOff, 0, 5);
      carrier.leds.show();
      printRow(F("Door Closed"));
      delay(2000);
    }
  }
  return true;
}

//############ Update displayed Info  ##############
void updateScreen() {

  //clear background of top text
  carrier.display.fillRect(0, 50, 240, 105, BACKGROUND_COLOR);

  carrier.display.setTextColor(TEXT_COLOR);
  carrier.display.setTextSize(TEXT_SIZE);

  carrier.display.setCursor(40, 50);
  carrier.display.print(F("Temp:"));
  carrier.display.print(currentTempF);
  carrier.display.setCursor(40, 85);
  carrier.display.print(F("RH%: "));
  carrier.display.print(humidity);
  carrier.display.setCursor(40, 120);

  //get status text color
  if (currentStatus == statusOff) {
    carrier.display.setTextColor(OFF_TEXT_COLOR);
  } else if (currentStatus == statusHigh) {
    carrier.display.setTextColor(HIGH_TEXT_COLOR);
  } else if (currentStatus == statusLow) {
    carrier.display.setTextColor(LOW_TEXT_COLOR);
  }

  carrier.display.print(F("Heat:"));
  carrier.display.print(getStatusText());
}

//############ Printrow  ##############
// prints a row of text below main status
void printRow( String  toPrint) {
  //clear lower text
  carrier.display.fillRect(0, 155, 240, 85, BACKGROUND_COLOR);
  carrier.display.setTextSize(smaller_TEXT_SIZE);
  carrier.display.setTextColor(TEXT_COLOR);
  carrier.display.setCursor(40, 155);
  carrier.display.print(toPrint);
}

//############ Printrow  Int ##############
// prints a row of text below main status with an integer
void printRowInt( String  toPrint, int printThisInt) {
  //clear lower text
  carrier.display.fillRect(0, 155, 240, 85, BACKGROUND_COLOR);
  carrier.display.setTextSize(smaller_TEXT_SIZE);
  carrier.display.setCursor(40, 155);
  carrier.display.print(toPrint);
  carrier.display.print(printThisInt);
}

//############ Get Status Text for Screen  ##############
char * getStatusText() {

  switch (currentStatus) {
    case statusInitializing:
      return statusInitializingText;
    case statusOff:
      return statusOffText;
    case statusLow:
      return statusLowText;
    case statusHigh:
      return statusHighText;
    default:
      return statusUnknownText;
  }
}

//############ Check temperature thresholds  ##############
void checkThresholds() {

  //get current relay state
  relayState = digitalRead(RELAYPIN);

  //check current state against current temp
  if (currentTempF < lowSetTemp) {
    if (currentStatus != statusHigh) {
      //we are just turning on
      currentStatus = statusHigh;
      incrementIntermittentSettings(intensityIncrementAmount);//bring pecentage up of how much is runs up when on low heat
    }
    digitalWrite(RELAYPIN, HIGH); //turn on relay

  } else if (currentTempF > highSetTemp) {
    if (currentStatus != statusOff) {
      //just turning off
      currentStatus = statusOff;
      incrementIntermittentSettings((-1 * intensityIncrementAmount)); //bring pecentage down of how much is runs up when on low heat
    }
    digitalWrite(RELAYPIN, LOW); //turn off relay

  } else {
    //we are between high and low

    //let's check if we are first starting
    if (currentStatus == statusInitializing) {
      currentStatus = statusLow;
      //just turning to low heat from turning on
      //random whether we are on or off to start
      if (random(1, 3) > 1) {
        //turn on
        printRow( F("#heat int ON"));
        digitalWrite(RELAYPIN, HIGH); //turn on relay
        cycleLastChange = millis();
        delay(2000);
      } else {
        //turn off
        printRow(F( "#heat int OFF"));
        digitalWrite(RELAYPIN, LOW); //turn off relay
        cycleLastChange = millis();
        delay(2000);
      }

    } else  if (currentStatus != statusLow) {
      //we just jumped into low heat
      //leave relay as it was
      currentStatus = statusLow;
      cycleLastChange = millis(); //reset our counter
      //don't change the relay state, leave it in whatever state it was in
    } else {
      //we were already in mid-cycle, let's check status duration
      if (relayState == 1) {
        if ((millis() - cycleLastChange) > cycleUpTime) {
          printRow(F( "#setting int OFF"));
          digitalWrite(RELAYPIN, LOW); //turn off relay
          cycleLastChange = millis();
          delay(2000);
        } else {
          digitalWrite(RELAYPIN, HIGH);
        }

      } else {
        //relayState == 0  or weirdness
        if ((millis() - cycleLastChange) > cycleDownTime) {
          printRow(F( "#setting int ON"));
          digitalWrite(RELAYPIN, HIGH); //turn on relay
          cycleLastChange = millis();
          delay(2000);
        } else {
          digitalWrite(RELAYPIN, LOW);
        }

      }
    }
  }//end of if/else for temps
  relayState = digitalRead(RELAYPIN);//read it in case it just changed
}

//############ Read the Temperature  ##############
bool readTemp(void *) {
  debugSerialln("reading temp");
  //get temp and convert to F
  float tempC = humiditySensor.getTemperature();
  float temporaryTempF = roundFloat(float((tempC * 1.8) + 32));

  float tempHumidity = humiditySensor.getHumidity();

  temps[tempsArrayIndicator] = temporaryTempF;
  humidities[tempsArrayIndicator++] = tempHumidity;

  //clear lower text
  carrier.display.fillRect(0, 155, 240, 85, BACKGROUND_COLOR);

  //update temp readings
  carrier.display.setTextSize(smaller_TEXT_SIZE);
  carrier.display.setTextColor(TEXT_COLOR);
  carrier.display.setCursor(40, 155);
  char indicator[] = "_";

  for (int i = 0; i < tempsArrayIndicator; i++) {
    carrier.display.print(indicator);
  }
  carrier.display.print(String(temporaryTempF, 2));

  debugSerialln("temp: " + String(temporaryTempF, 2));

  //let's see if we have tempsToRound temps to average
  if (tempsArrayIndicator >= tempsToRound) {
    float tempTotal = 0.0;
    float humidityTotal = 0.0;
    for (int i = 0; i < tempsToRound; i++) {
      tempTotal += temps[i];
      humidityTotal += humidities[i];
    }
    float roundedTemp = roundFloat(tempTotal / tempsToRound);
    currentTempF = roundedTemp;//not sure if this line is needed
    tempF = roundedTemp; //added
    debugSerialln("new Temp: " + String(currentTempF, 2));
    float roundedHumidity = roundFloat(humidityTotal / tempsToRound);
    humidity = roundedHumidity;
    debugSerialln("new Humdidity: " + String(humidity, 1));
    checkThresholds();//see if we need to change relay states
    updateScreen();
    tempsArrayIndicator = 0;
  }
  return true;
}

//############ Increment the percentage on the low heat setting  ##############
void incrementIntermittentSettings(int increaseAmount) {
  lowTempIntensity += increaseAmount;

  //keep this between 0 and 100
  if (lowTempIntensity > 100) {
    lowTempIntensity = 100;
  }

  if (lowTempIntensity < 0) {
    lowTempIntensity = 0;
  }

  cycleUpTime = (lowTempCycleDuration * lowTempIntensity) / 100;
  cycleDownTime = lowTempCycleDuration - cycleUpTime;
}

//############ Round a float to 2 digits  ##############
float roundFloat(float x) {
  x = x + 0.005;
  x = x * 100;
  int y = (int)x;
  float z = (float)y / 100;
  return z;
}

//##############################################
//############ Arduino Functions  ##############
//##############################################

/*
  Since HighTemp is READ_WRITE variable, onHighTempChange() is
  executed every time a new value is received from IoT Cloud.
  //these are currently not working, need to port to adafruit
*/
void onHighTempChange()  {
  highSetTemp = highTemp;
  debugSerial("new High Temp:");
  debugSerialln(highSetTemp);
  printRowInt(F("high temp:"), highSetTemp);
  delay(2000);//let it show in screen
}

/*
  Since LowTemp is READ_WRITE variable, onLowTempChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLowTempChange()  {
  lowSetTemp = lowTemp;
  debugSerial("new low temp:");
  debugSerialln(lowSetTemp);
  printRowInt(F("low temp:"), lowSetTemp);
  delay(2000);//let it show in screen
}

/*
  Since LowTempIntensity is READ_WRITE variable, onLowTempIntensityChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLowTempIntensityChange()  {
  incrementIntermittentSettings(0);
  debugSerial("new low temp percentage:");
  debugSerialln(lowTempIntensity);
  printRowInt(F("low %:"), lowTempIntensity);
  delay(2000);//let it show in screen
}

/*
  Since IntensityIncrementAmount is READ_WRITE variable, onIntensityIncrementAmountChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onIntensityIncrementAmountChange()  {
  debugSerial("new increment amount:");
  debugSerialln(intensityIncrementAmount);
  printRowInt(F("low %:"), intensityIncrementAmount);
  delay(2000);//let it show in screen
}

//############ MQTT_connect  ##############
void MQTT_connect() {
  int8_t ret;

  // Stop if already connected.
  if (mqtt.connected()) {
    return;
  }

  debugSerial("Connecting to MQTT... ");

  uint8_t retries = 3;
  while ((ret = mqtt.connect()) != 0) { // connect will return 0 for connected
    debugSerialln(mqtt.connectErrorString(ret));
    debugSerialln("Retrying MQTT connection in 5 seconds...");
    mqtt.disconnect();
    delay(5000);  // wait 5 seconds
    retries--;
    if (retries == 0) {
      // basically die and wait for WDT to reset me
      while (1);
    }
  }
  debugSerialln("MQTT Connected!");
}
